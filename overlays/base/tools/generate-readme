#!/usr/bin/env python3
"""
Dynamic README Generator for Exousia Bootc Images

Generates comprehensive documentation with:
- Automatic Table of Contents
- Collapsible sections for verbose content
- Current build configuration from adnyeus.yml
"""

import argparse
import os
import re
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional
from urllib.parse import quote

try:
    import yaml
except ImportError:
    yaml = None


class Colors:
    """Terminal colors (disabled in CI)."""
    def __init__(self):
        if os.environ.get('CI') == 'true':
            self.GREEN = self.BLUE = self.YELLOW = self.RED = self.NC = ''
        else:
            self.GREEN = '\033[0;32m'
            self.BLUE = '\033[0;34m'
            self.YELLOW = '\033[1;33m'
            self.RED = '\033[0;31m'
            self.NC = '\033[0m'

    def success(self, msg: str) -> None:
        print(f"{self.GREEN}✓{self.NC} {msg}")

    def info(self, msg: str) -> None:
        print(f"{self.BLUE}ℹ{self.NC} {msg}")

    def warning(self, msg: str) -> None:
        print(f"{self.YELLOW}⚠{self.NC} {msg}")

    def error(self, msg: str) -> None:
        print(f"{self.RED}✗{self.NC} {msg}", file=sys.stderr)


class Config:
    """Build configuration extracted from repository."""
    def __init__(self):
        self.os_name = "Linux"
        self.os_logo = "linux"
        self.os_badge_color = "0A74DA"
        self.os_version = ""
        self.image_type = ""
        self.image_type_display = ""
        self.wm_de_label = "Unknown"
        self.github_repo = ""
        self.github_owner = ""
        self.docker_image = ""
        self.build_date = ""
        self.build_badge_text_uri = ""


def get_repo_root() -> Path:
    """Determine repository root reliably."""
    if github_ws := os.environ.get('GITHUB_WORKSPACE'):
        return Path(github_ws)

    script_path = Path(__file__).resolve()
    # overlays/base/tools/generate-readme -> repo root
    return script_path.parent.parent.parent.parent


def extract_config(repo_root: Path, colors: Colors) -> Config:
    """Extract configuration from repository metadata."""
    config = Config()
    colors.info(f"Repository root: {repo_root}")

    adnyeus_path = repo_root / "adnyeus.yml"
    base_image = ""

    # Parse adnyeus.yml
    if adnyeus_path.exists():
        colors.info(f"Found image definition blueprint: {adnyeus_path}")

        if yaml:
            with open(adnyeus_path) as f:
                blueprint = yaml.safe_load(f)
            base_image = blueprint.get('base-image', '')
            config.os_version = str(blueprint.get('image-version', ''))

            # Get desktop/window manager
            desktop = blueprint.get('desktop', {})
            de = desktop.get('desktop_environment', '')
            wm = desktop.get('window_manager', '')

            if de:
                de_labels = {
                    'gnome': 'GNOME',
                }
                config.wm_de_label = de_labels.get(de.lower(), de.capitalize())
            elif wm:
                config.wm_de_label = wm.capitalize()
        else:
            # Fallback to regex parsing if PyYAML not available
            content = adnyeus_path.read_text()
            if match := re.search(r'^base-image:\s*(.+)$', content, re.MULTILINE):
                base_image = match.group(1).strip().strip('"\'')
            if match := re.search(r'^image-version:\s*(.+)$', content, re.MULTILINE):
                config.os_version = match.group(1).strip().strip('"\'')
            if match := re.search(r'window_manager:\s*(.+)$', content, re.MULTILINE):
                config.wm_de_label = match.group(1).strip().strip('"\'').capitalize()
    else:
        colors.warning("adnyeus.yml not found; relying on pipeline inputs")

    # Detect OS from base image
    if base_image:
        base_lower = base_image.lower()
        os_map = {
            'fedora': ('Fedora', 'fedora', '0A74DA'),
        }
        for key, (name, logo, color) in os_map.items():
            if key in base_lower:
                config.os_name, config.os_logo, config.os_badge_color = name, logo, color
                break

        # Extract version from base image tag if not set
        if not config.os_version and ':' in base_image:
            config.os_version = base_image.rsplit(':', 1)[1].split('@')[0]

    # Check .fedora-version file (takes precedence)
    version_file = repo_root / ".fedora-version"
    if version_file.exists() and version_file.stat().st_size > 0:
        version_info = version_file.read_text().strip()
        parts = version_info.split(':')
        config.os_version = parts[0]
        if len(parts) > 1:
            config.image_type = parts[1]

    # Set display name
    type_displays = {
        'fedora-sway-atomic': 'Fedora Sway Atomic Desktop',
        'fedora-bootc': 'Fedora bootc Base',
    }
    config.image_type_display = type_displays.get(config.image_type, config.image_type or 'Unknown')

    if not config.os_version:
        config.os_version = "unknown"

    if config.os_version:
        colors.info(f"Blueprint version detected: {config.os_name} {config.os_version}")

    # Get GitHub repository
    if github_repo := os.environ.get('GITHUB_REPOSITORY'):
        config.github_repo = github_repo
    else:
        try:
            result = subprocess.run(
                ['git', '-C', str(repo_root), 'remote', 'get-url', 'origin'],
                capture_output=True, text=True, check=True
            )
            url = result.stdout.strip()
            # Extract owner/repo from various URL formats
            match = re.search(r'[:/]([^/]+/[^/]+?)(?:\.git)?$', url)
            if match:
                config.github_repo = match.group(1).replace('.git', '')
                # Clean up proxy paths
                if '/git/' in config.github_repo:
                    config.github_repo = config.github_repo.split('/git/')[-1]
                colors.info(f"Detected GitHub repository: {config.github_repo}")
        except (subprocess.CalledProcessError, FileNotFoundError):
            colors.warning("Could not detect GitHub repository, using default")
            config.github_repo = "borninthedark/exousia"

    config.github_owner = config.github_repo.split('/')[0]
    config.docker_image = "docker.io/1borninthedark/exousia"
    config.build_date = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S UTC")

    badge_text = f"{config.os_name} {config.os_version} • {config.wm_de_label}"
    config.build_badge_text_uri = quote(badge_text)

    return config


def generate_toc(sections: list[tuple[str, str, int]]) -> str:
    """Generate Table of Contents from sections.

    Args:
        sections: List of (title, anchor, level) tuples
    """
    lines = ["## Table of Contents", ""]
    for title, anchor, level in sections:
        indent = "  " * (level - 2)
        lines.append(f"{indent}- [{title}](#{anchor})")
    return "\n".join(lines)


def slugify(title: str) -> str:
    """Convert title to GitHub anchor slug."""
    slug = title.lower()
    slug = re.sub(r'[^\w\s-]', '', slug)
    slug = re.sub(r'\s+', '-', slug)
    return slug


def collapsible(summary: str, content: str) -> str:
    """Wrap content in a collapsible details block."""
    return f"""<details>
<summary>{summary}</summary>

{content}
</details>"""


def generate_readme(config: Config) -> str:
    """Generate the complete README content."""

    # Define all sections for ToC
    sections = [
        ("Highly Experimental Disclaimer", "highly-experimental-disclaimer", 2),
        ("Project Snapshot", "project-snapshot", 2),
        ("Build & Release Workflow", "build--release-workflow", 2),
        ("Getting Started", "getting-started", 2),
        ("Triggering Builds Remotely", "triggering-builds-remotely", 2),
        ("Customizing Builds", "customizing-builds", 2),
        ("YubiKey Authentication (PAM U2F)", "yubikey-authentication-pam-u2f", 2),
        ("Package Validation & Dependency Tooling", "package-validation--dependency-tooling", 2),
        ("Required Secrets", "required-secrets", 2),
        ("Documentation", "documentation", 2),
        ("Contributing", "contributing", 2),
        ("License", "license", 2),
        ("Acknowledgments", "acknowledgments", 2),
    ]

    toc = generate_toc(sections)

    # Python webhook examples
    python_examples = '''```bash
# Set your Forgejo token
export GITHUB_TOKEN="your_token_here"

# Trigger a build using repo defaults
python tools/webhook_trigger.py

# Trigger specific image type and version
python tools/webhook_trigger.py \\
  --image-type fedora-sway-atomic \\
  --distro-version 43 \\
  --enable-plymouth

# Build with specific window manager
python tools/webhook_trigger.py --wm sway --distro-version 43
```'''

    python_advanced = '''```bash
# Use a YAML definition file
python tools/webhook_trigger.py --yaml sway-bootc.yml --distro-version 44

# Disable Plymouth
python tools/webhook_trigger.py --yaml sway-atomic.yml --disable-plymouth --verbose
```'''

    # cURL example for GitHub Actions API
    curl_basic = '''```bash
# Trigger a build via GitHub Actions workflow dispatch
curl -X POST \\
  -H "Accept: application/vnd.github+json" \\
  -H "Authorization: Bearer $GITHUB_TOKEN" \\
  https://api.github.com/repos/borninthedark/exousia/actions/workflows/el.yml/dispatches \\
  -d '{
    "ref": "main",
    "inputs": {
      "image_type": "fedora-bootc",
      "distro_version": "43",
      "enable_plymouth": "true"
    }
  }'
```'''

    curl_advanced = '''```bash
# Build Sway Atomic variant
curl -X POST \\
  -H "Accept: application/vnd.github+json" \\
  -H "Authorization: Bearer $GITHUB_TOKEN" \\
  https://api.github.com/repos/borninthedark/exousia/actions/workflows/el.yml/dispatches \\
  -d '{"ref": "main", "inputs": {"image_type": "fedora-sway-atomic", "distro_version": "43", "enable_plymouth": "true"}}'
```'''

    # Pre-generate all collapsible sections
    python_advanced_section = collapsible("More Python examples", python_advanced)
    curl_advanced_section = collapsible("More cURL examples", curl_advanced)
    readme = f'''# Exousia: Declarative Bootc Builder

[![Last Build: {config.os_name} {config.os_version} • {config.wm_de_label}](https://img.shields.io/badge/Last%20Build-{config.build_badge_text_uri}-{config.os_badge_color}?style=for-the-badge&logo={config.os_logo}&logoColor=white)](#build--release-workflow)
[![Highly Experimental](https://img.shields.io/badge/Highly%20Experimental-DANGER%21-E53935?style=for-the-badge&logo=skull&logoColor=white)](#highly-experimental-disclaimer)
[![Pre-commit](https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&logoColor=white)](https://github.com/pre-commit/pre-commit)

Build custom, container-based immutable operating systems using the [**bootc project**](https://github.com/bootc-dev/bootc). Images are built, tested, and published via GitHub Actions to DockerHub.

Exousia builds custom, container-based immutable operating systems using [bootc](https://github.com/bootc-dev/bootc) and GitHub Actions. It focuses on reproducible, security-conscious laptop images with fast iteration cycles.

{toc}

---

## Highly Experimental Disclaimer

> **Warning**: This project is highly experimental. There are **no guarantees** about stability, data safety, or fitness for any purpose. Proceed only if you understand the risks.

---

## Project Snapshot

- **Purpose:** Declarative laptop images with a DevSecOps-friendly workflow.
- **Outputs:** bootc Sway images published to DockerHub.
- **Tooling:** Python CLI tools in `tools/`, YAML-based blueprints, and `just` task runner.
- **Security/Quality:** Linting, scanning, and automated tests baked into CI.

---

## Build & Release Workflow

### Semantic Versioning

Version bumps are determined automatically from [conventional commits](https://www.conventionalcommits.org/):
- `feat:` → minor bump
- `fix:` → patch bump
- `feat!:` or `BREAKING CHANGE:` → major bump

### CI/CD Pipeline (Phoenician Pantheon)

All workflows use Phoenician mythology-themed names and run on GitHub Actions.

| Workflow | Role | Trigger |
|----------|------|---------|
| **El** | Orchestrator (king of the gods) | Push to main, PR |
| **Anat** | CI: lint, test, validate (goddess of wisdom) | Called by El |
| **Resheph** | Security: Checkov, Trivy, Bandit (god of protection) | Called by El |
| **Kothar** | Build + push to DockerHub (god of craftsmanship) | Called by El |
| **Eshmun** | Release: semver, retag, GitHub Release (god of renewal) | After gate on main |

### Pipeline Stages

| Stage | What happens |
|-------|--------------|
| **Anat** | Hadolint, file structure, Containerfile gen, Ruff, Black, pytest + Codecov |
| **Resheph** | Checkov (Containerfile), Trivy config scan, Bandit SAST |
| **Kothar** | Buildah image build, DockerHub push, Trivy image scan, Cosign signing |
| **Eshmun** | Semver from commits, retag image, GitHub Release |

**Triggers:** pushes to `main`, pull requests, and manual workflow dispatch.

---

## Getting Started

### Prerequisites

- Fedora system (Atomic variant recommended)
- DockerHub account (or local container registry)
- Basic familiarity with bootc/container workflows

### Use a Published Image

> **Flathub Setup**
>
> Exousia installs applications like Firefox and VS Code via Flatpak. To use Flathub apps, set up the remote before switching images:
>
> ```bash
> flatpak remote-add --if-not-exists --system flathub https://dl.flathub.org/repo/flathub.flatpakrepo
> ```

```bash
# From DockerHub
sudo bootc switch docker.io/1borninthedark/exousia:latest
sudo bootc upgrade && sudo systemctl reboot
```

### Build Locally

```bash
git clone <your-forgejo-url>/exousia.git
cd exousia
just build
```

---

## Triggering Builds Remotely

Trigger builds programmatically via the webhook API.

**Prerequisites:** GitHub API token, Python 3.11+ with `requests`

### Python CLI

{python_examples}

{python_advanced_section}

### cURL API

{curl_basic}

{curl_advanced_section}

View builds on [GitHub Actions](https://github.com/borninthedark/exousia/actions) | [Webhook API Guide](docs/WEBHOOK_API.md)

---

## Customizing Builds

### Switch Blueprint Versions

```bash
# Via webhook CLI
python tools/webhook_trigger.py --image-type fedora-bootc --distro-version 44
python tools/webhook_trigger.py --image-type fedora-sway-atomic --distro-version 43
```

Or use the manual workflow dispatch in the GitHub Actions UI.

### Adjust Packages

| Scope | Where to edit | What to change |
|-------|---------------|----------------|
| Base packages | `overlays/base/packages/common/*.yml` | Add/remove shared package sets |
| Window managers | `overlays/base/packages/window-managers/*.yml` | Add to the relevant categories |

All package additions are managed from the `overlays/base/packages/` directory via the package loader; avoid editing YAML definitions for package lists.

### Configuration Files

| Directory | Purpose |
|-----------|---------|
| `overlays/sway/configs/sway/` | Sway WM and config.d snippets |
| `overlays/sway/configs/greetd/` | Display manager (greetd) |
| `overlays/sway/configs/plymouth/` | Boot splash themes |
| `overlays/sway/configs/swaylock/` | Swaylock screen lock |
| `overlays/base/configs/pam.d/` | PAM authentication (YubiKey U2F) |
| `overlays/sway/scripts/runtime/` | Runtime scripts (autotiling, lid, volume-helper) |
| `overlays/sway/scripts/setup/` | Build-time setup scripts |
| `overlays/base/tools/` | Shared scripts |

### Desktop & Boot Experience

- **Sway** uses `sway-config-minimal` for headless/container compatibility.
  - `/usr/share/sway/config.d/*.conf` — Packaged configs
  - `/etc/sway/config.d/*.conf` — System overrides
  - `~/.config/sway/config.d/*.conf` — User overrides
  - See [Fedora Sericea Configuration Guide](https://docs.fedoraproject.org/en-US/fedora-sericea/configuration-guide/).
- **Plymouth**: Set `enable_plymouth: true` in YAML; themes live in `overlays/sway/configs/plymouth/themes/`.
- **Display managers**: all images use greetd.

---

## YubiKey Authentication (PAM U2F)

Exousia includes built-in support for YubiKey hardware authentication using PAM U2F. This allows you to use your YubiKey as a second factor or alternative authentication method for `sudo`, login, and other PAM-aware services.

### Configuration

The system includes pre-configured PAM modules in `overlays/base/configs/pam.d/`:
- `u2f-required` — YubiKey authentication is mandatory
- `u2f-sufficient` — YubiKey OR password authentication (default for sudo)

By default, `sudo` is configured to accept YubiKey authentication as an alternative to password authentication. If your YubiKey is present and registered, you can use it instead of entering your password.

### Setup

After deploying an Exousia image, register your YubiKey(s):

```bash
# Create credential directory
mkdir -p ~/.config/Yubico

# Register your primary YubiKey
pamu2fcfg > ~/.config/Yubico/u2f_keys

# Register backup YubiKey (recommended)
pamu2fcfg -n >> ~/.config/Yubico/u2f_keys
```

### Usage

Once registered, touch your YubiKey when prompted during `sudo` authentication. If the YubiKey is not present or registration fails, standard password authentication is used as a fallback.

For more details, see the [Fedora YubiKey Quick Docs](https://docs.fedoraproject.org/en-US/quick-docs/using-yubikeys/).

---

## Package Validation & Dependency Tooling

### Package Dependency Checker

Fedora package dependency validation and verification.

```bash
python3 tools/package_dependency_checker.py --packages python3-requests neovim
python3 tools/package_dependency_checker.py --verify-only --json
```

### Validation CLI

```bash
python3 tools/validate_installed_packages.py --yaml adnyeus.yml --image-type fedora-bootc
python3 tools/validate_installed_packages.py --wm sway --distro fedora
```

---

## Required Secrets

Configure in GitHub repository settings under **Settings → Secrets and variables → Actions**:

**Secrets:**

| Secret | Purpose |
|--------|---------|
| `DOCKERHUB_USERNAME` | DockerHub username |
| `DOCKERHUB_TOKEN` | DockerHub access token |

**Variables:**

| Variable | Purpose |
|----------|---------|
| `DOCKERHUB_IMAGE` | Image path (e.g., `1borninthedark/exousia`) |
| `REGISTRY_URL` | Registry URL (e.g., `docker.io`) |

---

## Documentation

**[Full Documentation Index](docs/README.md)**

| Topic | Links |
|-------|-------|
| Getting Started | [Upgrade Guide](docs/BOOTC_UPGRADE.md) &#124; [Image Builder](docs/BOOTC_IMAGE_BUILDER.md) |
| Testing | [Guide](docs/testing/README.md) &#124; [Writing Tests](docs/reference/writing-tests.md) |
| Reference | [Troubleshooting](docs/reference/troubleshooting.md) &#124; [Webhook API](docs/WEBHOOK_API.md) |

---

## Contributing

Contributions welcome! Submit PRs or open issues. Use [conventional commits](https://www.conventionalcommits.org/) for automatic versioning.

---

## AI-Assisted Development

This project was developed with assistance from [Claude Code](https://docs.anthropic.com/en/docs/claude-code), [ChatGPT Codex](https://chatgpt.com/codex), and [GitHub Dependabot](https://docs.github.com/en/code-security/dependabot) for automated dependency security updates.

---

## License

MIT License — see LICENSE file.

---

## Acknowledgments

- [bootc project](https://github.com/bootc-dev/bootc) maintainers and Fedora community
- [Fedora Sway SIG](https://gitlab.com/fedora/sigs/sway/sway-config-fedora) for Sway configs and QoL improvements
- [openSUSEway](https://github.com/openSUSE/openSUSEway) for Sway enhancements
- [Universal Blue](https://universal-blue.org/) and [BlueBuild](https://blue-build.org/) for container-native workflows
- [GitHub Actions](https://github.com/features/actions) for CI/CD pipelines
- [Buildah](https://buildah.io/), [Skopeo](https://github.com/containers/skopeo), [Podman](https://podman.io/)
- **Claude** (Anthropic) and **GPT Codex** (OpenAI) for AI-assisted development

### Creative Acknowledgments

**Tite Kubo** — Creator of *BLEACH*. The "Reiatsu" status indicator is inspired by themes from BLEACH, used respectfully as a playful aesthetic. All rights belong to Tite Kubo and respective copyright holders.

---

**Built with [bootc](https://github.com/bootc-dev/bootc)** | [Docs](https://bootc-dev.github.io/bootc/) | [Fedora bootc](https://docs.fedoraproject.org/en-US/bootc/)

*Generated on {config.build_date}*
'''

    return readme


def main():
    parser = argparse.ArgumentParser(
        description="Generate dynamic README.md with current build configuration"
    )
    parser.add_argument('--image-type', help="Override image type")
    parser.add_argument('--dry-run', action='store_true', help="Preview without writing")
    args = parser.parse_args()

    colors = Colors()
    repo_root = get_repo_root()
    readme_path = repo_root / "README.md"

    colors.info("Extracting configuration from repository metadata...")
    config = extract_config(repo_root, colors)

    if args.image_type:
        config.image_type = args.image_type
        colors.info(f"Using custom image type: {config.image_type}")

    colors.info("Configuration detected:")
    print(f"  - OS: {config.os_name} {config.os_version}")
    print(f"  - Image Type: {config.image_type_display}")
    print(f"  - GitHub Repo: {config.github_repo}")
    print(f"  - Docker Image: {config.docker_image}")
    print()

    readme_content = generate_readme(config)

    if args.dry_run:
        colors.info("Dry run mode - displaying generated content:")
        print("─" * 50)
        print(readme_content)
        print("─" * 50)
        colors.warning("Dry run complete - README.md was not modified")
    else:
        colors.info("Generating README.md...")
        readme_path.write_text(readme_content)
        colors.success(f"README.md generated successfully at: {readme_path}")

        if os.environ.get('CI') != 'true':
            print()
            colors.info("Next steps:")
            print("  1. Review the generated README: less README.md")
            print("  2. Commit the changes: git add README.md && git commit")


if __name__ == "__main__":
    main()
